You are working on a CodeCommit project, which means that the project will be
following a CodeCommit structure. The project has a top level src/ directory,
and may have modules within the source directory, one module per folder.
Modules may recursevely contain their own modules as well.

Every module should have the following three documentation files:

+ APISignatures.md
+ ModuleDependencies.md
+ UserSpecification.md

APISignatures.md provides the signature for every type and function that is
exported by the module. The signatures are provided so that the functions and
structs may be used accurately in an implementation, but they are not
explained. The signatures should aim to be self-explanatory, supplemented by
the UserSpecification for more robust documentation.

ModuleDependencies.md lists out all of the internal modules that this module
directly imports as a dependency. The file must start with the following two
lines exactly:

```
# Module Dependencies

```

These two lines are followed by a list of dependencies. A dependency is only
valid if it refers to another module. Recall that a module is defined as a
sub-folder that contains a UserSpecification.md file.

UserSpecification.md files are user-written files that contain specifications
for the project and its modules. You are not allowed to create or modify any
UserSpecification.md file under any circumstances - if you attempt to do so,
the entire request will fail and no changes will be made to the code at all.

The top level of the project also contains a UserSpecification.md file. This
user specification is intended to work in tandem with all of the other
UserSpecification files to fully define the project.

When in doubt, the UserSpecification files are treated as the baseline truth
for the project. The implementation needs to follow the UserSpecification. The
implementation is never "correct" if it deviates from the UserSpecification.

CodeCommit projects are designed for agentic workflows. Often times, agents are
navigating the project structure using nothing more than the names of each file
in the project, and the APISignatures.md files of each module. To ensure the
agents can be effective with such sparse information, it is critical that the
filenames clearly indicate what code resides inside, and that the function
names, object names, and field names of the public API be self-explanatory.

CodeCommit projects have very few comments, often no comments at all. This is
because CodeCommit projects are always read and maintained by expert LLMs.
Comments should only ever be included if they are absolutely necessary for an
expert LLM to understand how the code works.

Files must remain small and focused, as this maximizes the overall flexibility
of the different agentic workflows. As a rule of thumb, files should not
contain more than 300 lines of code, and each file should have one specific
theme. Files such as 'utils.rs' or 'helpers.rs' are strictly not allowed, as an
agent has little hope of guessing what code exists inside of that file based on
the name alone. The filename must clearly and specifically indicate what code
is inside, which means the code must have a small enough scope that it can be
described in a single filename of reasonable length. If you have a bunch of
one-off fuctions, it is better to put each function in its own file, than to
create a single file with a generic name.

Code must be written in idiomatic rust. The code attempts to be a professional
codebase with high quality standards, and should be developed with security and
adversarial conditions in mind. This means that there must be robust testing.
Code should also be plain and simple, such that a junior engineer could easily
understand the code even if there are no comments. Code must be meticulous and
professional.

All custom error types should implement the std::fmt::Display trait as well as
the std::error::Error trait.

Configuration must depend on reading files, not on reading environment
variables.

You are not allowed to create new modules yourself. You must modify code within
the existing set of modules, and something does not count as a module until it
contains a UserSpecification.md. Because each sub-folder counts as a module,
you are also not allowed to create sub-folders.

Tests must always exist in their own files, and those files must have the
suffix '_test.rs'.

Any tests you write must be highly scalable, and must not be prone to NDFs. You
must assume that any test you write is one of many tests, and that some of the
other tests will be checking the same logic that you are. You must also assume
that the test suite might be run multiple times in parallel from the same
directory. This means that any tests which require persistence will need to use
randomized names for their files and folders. Tests should not write to common
files, any writing that a test does must use a fresh file with a randomized
filename. Tests also should not assume that they will be cleaned up if they
error out early, test design should avoid patterns where one test failure could
cause other tests to also fail due to contaminated state. Please be meticulous
when designing tests.
